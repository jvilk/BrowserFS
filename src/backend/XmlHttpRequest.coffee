# IE9 and below only: Injects a VBScript function that converts the
# 'responseBody' attribute of an XMLHttpRequest into a bytestring.
# Credit: http://miskun.com/javascript/internet-explorer-and-binary-files-data-access/#comment-11
document.write(
  "<!-- IEBinaryToArray_ByteStr -->\r\n"+
  "<script type='text/vbscript'>\r\n"+
  "Function IEBinaryToArray_ByteStr(Binary)\r\n"+
  " IEBinaryToArray_ByteStr = CStr(Binary)\r\n"+
  "End Function\r\n"+
  "Function IEBinaryToArray_ByteStr_Last(Binary)\r\n"+
  " Dim lastIndex\r\n"+
  " lastIndex = LenB(Binary)\r\n"+
  " if lastIndex mod 2 Then\r\n"+
  " IEBinaryToArray_ByteStr_Last = Chr( AscB( MidB( Binary, lastIndex, 1 ) ) )\r\n"+
  " Else\r\n"+
  " IEBinaryToArray_ByteStr_Last = "+'""'+"\r\n"+
  " End If\r\n"+
  "End Function\r\n"+
  "</script>\r\n"
)

# A simple filesystem backed by XmlHttpRequests.
class BrowserFS.FileSystem.XmlHttpRequest extends BrowserFS.FileSystem
  # Constructs the file system.
  # @param [String] listing_url The path to the JSON file index generated by
  #   tools/XHRIndexer.coffee. This can be relative to the current webpage URL
  #   or absolutely specified.
  # @param [String] prefix_url The url prefix to use for all web-server requests.
  constructor: (listing_url='index.json',@prefix_url='') ->
    file_data = @_request_file(listing_url, 'json')
    listing = JSON.parse file_data
    unless listing?
      throw new Error "Unable to find listing at URL: #{listing_url}"
    @_index = BrowserFS.FileIndex.from_listing listing

  empty: ->
    for k, v of @_index._index when v.file_data?
      v.file_data = undefined

  # Assumes that path is in @_index.
  _request_file_modern: (path, data_type, cb) ->
    req = new XMLHttpRequest()
    req.open 'GET', @prefix_url + path, cb?
    req.responseType = data_type if cb?
    data = null
    req.onerror = (e) -> console.error req.statusText
    req.onload = (e) ->
      unless req.readyState is 4 and req.status is 200
        console.error req.statusText
      data = BrowserFS.node.Buffer(req.response ? 0)
      cb?(data)
    req.send()
    if data? and data != 'NOT FOUND'
      return data

  # Only requests the HEAD content, for the file size.
  _request_file_size: (path, cb) ->
    req = new XMLHttpRequest()
    req.open 'HEAD', @prefix_url + path
    req.onreadystatechange = (e) ->
      unless req.readyState is 4 and req.status is 200
        console.error req.statusText
      cb req.getResponseHeader('Content-Length')
    req.send()

  # Converts 'responseBody' in IE into the equivalent 'responseText' that other
  # browsers would generate.
  _GetIEByteArray_ByteStr: (IEByteArray) ->
    rawBytes = IEBinaryToArray_ByteStr(IEByteArray)
    lastChr = IEBinaryToArray_ByteStr_Last(IEByteArray)
    return rawBytes.replace(/[\s\S]/g,
      ((match) ->
        v = match.charCodeAt(0)
        return String.fromCharCode(v&0xff, v>>8)
      )) + lastChr

  # IE < 9 doesn't support array buffers.
  _request_file_IE: (path, data_type, cb) ->
    req = new XMLHttpRequest()
    req.open 'GET', @prefix_url + path, cb?
    req.setRequestHeader "Accept-Charset", "x-user-defined"
    data = null
    req.onreadystatechange = (e) =>
      # 4 means the request is complete.
      if req.readyState is 4
        if req.status is 200
          data_array = @_GetIEByteArray_ByteStr req.responseBody
          data = BrowserFS.node.Buffer data_array
          cb?(data)
        else
          console.error "ReadyState: #{req.readyState} Status: #{req.status}"
    req.send()
    if data? and data != 'NOT FOUND'
      return data

  # Dynamically determine which version to use.
  if BrowserFS.isIE and not window.Blob
    XmlHttpRequest.prototype._request_file = XmlHttpRequest.prototype._request_file_IE
  else
    XmlHttpRequest.prototype._request_file = XmlHttpRequest.prototype._request_file_modern

  # Returns the name of the file system.
  # @return [String]
  getName: -> 'XmlHttpRequest'
  # Does the browser support XmlHttpRequest?
  # @return [Boolean]
  @isAvailable: ->
    # Note: Older browsers use a different name for XHR, iirc.
    XMLHttpRequest?
  # Passes the size and taken space in bytes to the callback. Size will always
  # be equal to taken space, since this is a read-only file system.
  # @param [String] path Unused in the implementation.
  # @param [Function(Number, Number)] cb
  diskSpace: (path, cb) ->
    cb 0, 0
  # Returns true; this filesystem is read-only.
  # @return [Boolean]
  isReadOnly: -> true
  # Returns false; this filesystem does not support symlinks.
  # @return [Boolean]
  supportsLinks: -> false
  # Returns false; this filesystem does not support properties.
  # @return [Boolean]
  supportsProps: -> false

  # Special XHR function: Preload the given file into the index.
  # @param [String] path
  # @param [BrowserFS.Buffer] buffer
  preloadFile: (path, buffer) ->
    inode = @_index.getInode path
    if inode is null
      throw new BrowserFS.ApiError BrowserFS.ApiError.NOT_FOUND, "#{path} not found."
    inode.size = buffer.length
    inode.file_data = new BrowserFS.File.NoSyncFile @, path, BrowserFS.FileMode.getFileMode('r'), inode, buffer
    return

  stat: (path, isLstat, cb) ->
    inode = @_index.getInode path
    if inode is null
      return cb new BrowserFS.ApiError BrowserFS.ApiError.NOT_FOUND, "#{path} not found."
    # At this point, a non-opened file will still have default stats from the listing.
    if inode.size < 0
      @_request_file_size path, (size) ->
        inode.size = size
        cb null, inode
    else
      stats = inode.getStats?() ? inode
      cb null, stats
    return

  open: (path, flags, mode, cb) ->
    # Check if the path exists, and is a file.
    inode = @_index.getInode path
    if inode is null
      return cb new BrowserFS.ApiError BrowserFS.ApiError.NOT_FOUND, "#{path} is not in the FileIndex."
    if inode.isDirectory()
      return cb new BrowserFS.ApiError BrowserFS.ApiError.NOT_FOUND, "#{path} is a directory."
    switch flags.pathExistsAction()
      when BrowserFS.FileMode.THROW_EXCEPTION, BrowserFS.FileMode.TRUNCATE_FILE
        return cb new BrowserFS.ApiError BrowserFS.ApiError.NOT_FOUND, "#{path} already exists."
      when BrowserFS.FileMode.NOP
        # Use existing file contents.
        # XXX: Uh, this maintains the previously-used flag.
        return cb(null, inode.file_data) if inode.file_data?
        # TODO: be lazier about actually requesting the file
        @_request_file path, 'arraybuffer', (buffer) =>
          inode.size = buffer.length  # we don't initially have file sizes
          inode.file_data = new BrowserFS.File.NoSyncFile @, path, flags, inode, buffer
          cb null, inode.file_data
        return
      else
        return cb new BrowserFS.ApiError BrowserFS.ApiError.INVALID_PARAM, 'Invalid FileMode object.'

  readdir: (path, cb) ->
    # Check if it exists.
    inode = @_index.getInode path
    if inode is null
      return cb new BrowserFS.ApiError BrowserFS.ApiError.NOT_FOUND, "#{path} not found."
    else if inode.isFile()
      return cb new BrowserFS.ApiError BrowserFS.ApiError.NOT_FOUND, "#{path} is a file, not a directory."
    cb null, inode.getListing()
